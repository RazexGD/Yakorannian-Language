fetch('../data/yakorannian_words.json')
    .then(response => response.json())
    .then(data => {
        data.words.forEach(word => {
            document.body.innerHTML += 
                <div class="word-card">
                    <h3>${word.word}</h3>
                    <p>Перевод: ${word.translation}</p>
                </div>
            ;
        });
    });
function playAudio(audioPath) {
  const player = document.getElementById('player');
  player.src = audioPath;
  player.play();
}
const translations = word.translations.ru.join(" / ");
function applyGrammarRules(word, context) {
  if (word.alternate_forms) {
    for (const form of word.alternate_forms) {
      if (context[form.condition]) {
        return form.form;
      }
    }
  }
  return word.word;
}

const currentContext = { sentence_type: "question" };
const displayedWord = applyGrammarRules(wordEntry, currentContext);
document.getElementById('context').addEventListener('change', updateDisplay);

function updateDisplay() {
  const context = {
    sentence_type: document.getElementById('context').value
  };
  
  wordsContainer.innerHTML = '';
  data.words.forEach(word => {
    const currentForm = applyGrammarRules(word, context);
    wordsContainer.innerHTML += `
      <div class="word-card">
        <h3>${currentForm}</h3>
        <p>${word.translations.ru.join ? word.translations.ru.join(' / ') : word.translations.ru}</p>
      </div>
    `;
  });
}
function declineNoun(word, caseName, number, gender) {
  const rules = grammarRules.nouns.declensions[caseName][number][gender];
  const stem = word.stem || word.word.slice(0, -1); // Автовыделение основы
  
  if (word.irregular?.[`${caseName}_${number}`]) {
    return word.irregular[`${caseName}_${number}`];
  }
  
  const ending = rules.find(end => 
    word.word.endsWith(end.replace(/[-\+]/g, ''))
    || rules[0];
  
  return stem + ending;
}


declineNoun("локко", "genitive", "plural", "masculine"); // → "локкув"

function conjugateVerb(word, person, number) {
  const pattern = grammarRules.verbs.conjugation_patterns
    .find(p => p.infinitive_endings.includes(word.infinitive_ending));
  
  const stem = word.stem || word.word.slice(0, -pattern.infinitive_endings[0].length);
  
  return stem + pattern.endings[number][person];
}

// Пример:
conjugateVerb("теннтіть", "1st", "singular"); // → "теннто"

function vocative(word) {
  const lastChar = word.word.slice(-1);
  const stem = word.stem || word.word.slice(0, -1);
  
  if (/[шщчжц]/.test(lastChar)) {
    return stem + "о";
  }
  return word.word + "ұ";
}

vocative("мағван"); // → "мағванұ"
vocative("тмітання"); // → "тмітаньви"

function autoDetectStem(word) {
  const endings = {
    "іть": 2,
    "ать": 2,
    "ть": 1,
    "ь": 1
  };
  
  for (const [end, cut] of Object.entries(endings)) {
    if (word.endsWith(end)) {
      return word.slice(0, -cut);
    }
  }
  return word;
}

const tests = [
  {input: "локко", case: "genitive", number: "plural", expected: "локкув"},
  {input: "кашить", person: "3rd", number: "singular", expected: "кашіт"}
];

if (/(ать|ить)$/.test(word)) { /* ... */ }
function playAudio(word) {
  const audio = new Audio(word.pronunciation.audio);
  audio.play();
}
